
var numObjs = 15

var worldPrior = function() {
  var marbles = randomInteger(numObjs+1) //15 marbles... 0-15 can sink
  return marbles
}

var utterancePrior = function() {
  var utterances = [
                    "Some",
                    "All",
                    "None"
                    // "mu"
                    ]
 return uniformDraw(utterances)
  // return utterances[discrete([1,1,1,10])]
}

var meaning = function(utt,world) {
  return utt=="Some"? world>0 :
  utt=="All"? world==numObjs :
  utt=="None"? world==0 :
  utt=="mu"? true :
  true
}

var binomialMarbles = function(theta){
  return map(function(x){return Math.exp(binomialERP.score([theta, 15], x))},_.range(0,16))
}


var doubleBinomialMarbles = function(theta1, theta2, mix){
  return map(
    function(x){
      return mix*Math.exp(binomialERP.score([theta1, 15], x)) + (1-mix)*Math.exp(binomialERP.score([theta2, 15], x))
    },
    _.range(0,16))
}

var wonkyLiteralListener = cache(function(utterance, prior) {
  Enumerate(function(){                                                                         
            var world = discrete(prior)
            // var cooperate = flip(cooperativity)
            var m = meaning(utterance, world)
            // var scr = cooperate ? (m?0:-Infinity) : 0
            condition(m)
            // console.log(world + " " + scr)
            return world
  })
})



var wonkySpeaker = cache(function(world, prior) {
  Enumerate(function(){
            var utterance = utterancePrior()
            // var cooperate = flip(cooperativity)
            var L = wonkyLiteralListener(utterance, prior)
            // var scr = cooperate ? L.score([],world) : 0
            factor(L.score([],world))
            // factor(0)
            return utterance
            })
})


var wonkyRSA = function(utterance,speakerOptimality, priorParams) {
  Enumerate(function(){
    var primary = flip(priorParams["mix"])
    var prior =  primary ? 
                 binomialMarbles(priorParams["theta1"]) :
                 binomialMarbles(priorParams["theta2"])
    var world = discrete(prior)

    var S = (utterance=='mu') ? 0 : wonkySpeaker(world, prior)

    var scr = (utterance!='mu')  ? 
                  speakerOptimality*S.score([],utterance) : 
                  0
    factor(scr)
    var queryStatement = {"world":world, "wonky":1-primary}
    return queryStatement
  })
}


