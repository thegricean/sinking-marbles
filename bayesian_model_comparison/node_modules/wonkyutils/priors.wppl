// time webppl priors.wppl --require wonkyutils

var dataFrame = function(rawCSV){
    return map(function(row){
        return _.object(_.zip(rawCSV[0],row))
    }, rawCSV.slice(1))
}

var foreach = function(lst, fn) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var marginalizeERP = function(myERP, label){
	Enumerate(function(){
		var x = sample(myERP)
		return x[label]
	})
}


var fpath = "/Users/mht/Documents/research/sinking-marbles/bayesian_model_comparison/priors/data/"
// var priorData = wonkyutils.readCSV(fpath + "priors_fourstep.txt").data
var priorData = wonkyutils.readCSV(fpath + "priors.txt").data
var df_prior = dataFrame(priorData.slice(0, priorData.length-1))

var items = _.uniq(_.pluck(df_prior, "Item"))
var states = _.range(0,16)


var linkingModel = function(theta1, theta2, mix, phi){
	Enumerate(function(){
		var guessing = flip(phi)
		var marbles =  guessing ? uniformDraw(states) : 
								flip(mix) ? binomial(theta1, 15) :
											binomial(theta2, 15)
		// var marbles =  primaryInterpretation ? binomial(theta1, 15) : binomial(theta2, 15)
		return marbles
	})
}

// var linkingModel = function(weights, thetas, phi){
// 	Enumerate(function(){
// 		var thetaOfInterest = thetas[discrete(weights)]
// 		var marbles = flip(phi) ? uniformDraw(states) : binomial(thetaOfInterest, 15)
// 		// var marbles =  primaryInterpretation ? binomial(theta1, 15) : binomial(theta2, 15)
// 		return marbles
// 	})
// }



var priorModel = function(){
	
	var phi = 0
	// var phi = uniform(0,1)

	foreach(items,
		function(item){
			// var itemData = _.pluck(subset(df_prior, "Item", item), "best_guess")
			var itemData = _.pluck(subset(df_prior, "Item", item), "response")
			// var mix = uniform(0,1)
			// var theta1 = uniform(0,1)
			// var theta2 = uniform(0,1)

			// var weights = dirichlet([1,1,1])
			// var weights = dirichlet([1,1])
			// var mix = 0.5
			var mix = uniform(0,1)

			var theta1 = uniform(0,1)
			var theta2 = uniform(0,1)
			var theta3 = 0
			// var theta3 = uniform(0,1)


			var predictionERP = linkingModel(theta1, theta2, mix, phi)
			// var predictionERP = linkingModel(weights, [theta1, theta2, theta3], phi)
			// var predictionERP = linkingModel(weights, [theta1, theta2], phi)

			var scr = reduce(function(d, memo){
				return memo + predictionERP.score([], wonkyutils.wpParseFloat(d))
			}, 0, itemData)

			// console.log(item + scr)
			factor(scr)

			// var mutinomialMarbles = map(function(s){return Math.exp(predictionERP.score([],s))},
			// 							_.range(0,16))
			// var mutinomialMarbles = map(function(s){
			// 	var cleanPredERP = linkingModel(weights, [theta1, theta2], 0)
			// 	return Math.exp(cleanPredERP.score([],s))
			// },
			// _.range(0,16))
			// query.add(item, theta)
			query.add(item, {theta1:theta1,
							theta2:theta2,
							mix:mix})
			// query.add(item, mutinomialMarbles)

			// query.add(["theta", item], theta)
			// query.add(["phi", item], phi)
		})
	
	// query.add(["phi", "global"], phi)
	return query
}

// var mhiter = 100000
// var burn = mhiter / 2
// var priorERP = IncrementalMH(priorModel, mhiter, {verbose:true, burnin: burn})
// console.log('model complete. writing data...')
// var outfile = "priors/results/priorBDA-binomials-byItemPhi_incrMH" + mhiter + "burn" + burn + ".csv"
// wonkyutils.priorERPwriter(priorERP, outfile)
// console.log('wrote to file ... ' + outfile)



// debugging /////////////////////////////////
// var resultsERP = linkingModel(0.99, 0.8)
// var itemData = _.pluck(subset(df_prior, "Item", "melted ice cubes"), "response")
// var scr = reduce(function(d, memo){
// 	return resultsERP.score([], wonkyutils.wpParseFloat(d))
// }, 0, itemData)
// scr



