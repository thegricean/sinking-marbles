var numObjs = 15

var worldPrior = function() {
  var marbles = randomInteger(numObjs+1) //15 marbles... 0-15 can sink
  return marbles
}

var utterancePrior = function() {
  var utterances = [
                    "Some",
                    "All",
                    "None"
                    // "mu"
                    ]
 return uniformDraw(utterances)
  // return utterances[discrete([1,1,1,10])]
}

var meaning = function(utt,world) {
  return utt=="Some"? world>0 :
  utt=="All"? world==numObjs :
  utt=="None"? world==0 :
  utt=="mu"? true :
  true
}

var binomialMarbles = function(theta){
  return map(function(x){return Math.exp(binomialERP.score([theta, 15], x))},_.range(0,16))
}


var doubleBinomialMarbles = function(theta1, theta2, mix){
  return map(
    function(x){
      return mix*Math.exp(binomialERP.score([theta1, 15], x)) + (1-mix)*Math.exp(binomialERP.score([theta2, 15], x))
    },
    _.range(0,16))
}


// var empiricalPriors = wonkyutils.readPriors()
var literalListener = cache(function(utterance, prior, accomodation, priorOpts) {
                            Enumerate(function(){
                                      var wonky = flip(priorOpts["wonkinessPrior"])
                                      var literalPrior = flip(accomodation) ? 
                                              prior : 
                                               wonky ? 
                                                binomialMarbles(priorOpts["backoffWeight"]) :
                                                binomialMarbles(priorOpts["primaryWeight"])
                                                                                
                                      var world = discrete(literalPrior)
                                      // var cooperate = flip(cooperativity)

                                      var m = meaning(utterance, world)
                                      // var scr = cooperate ? (m?0:-Infinity) : 0
                                      // factor(m?0:-Infinity)
                                      condition(m)
                                      // console.log(world + " " + scr)
                                      return world
                                      // return wonky
                                      })
                            })

// var speaker = cache(function(world, prior, cooperativity) {
var speaker = cache(function(world, prior, accomodation, priorOpts) {
                    Enumerate(function(){
                              var utterance = utterancePrior()
                              // var cooperate = flip(cooperativity)
                              var L = literalListener(utterance, prior, accomodation, priorOpts)
                              // var scr = cooperate ? L.score([],world) : 0
                              factor(L.score([],world))
                              // factor(0)
                              return utterance
                              })
                    })

// var fillerSpeaker = cache(function(world, prior) {
//                     Enumerate(function(){
//                               var utterance = uniformDraw(["mu"])
//                               var L = literalListener(utterance, prior)
//                               factor(L.score([],world))
//                               // console.log(world + L.score([],world) )
//                               return utterance
//                               })
//                     })



var listener = function(utterance,wonkinessPrior,speakerOptimality,cooperativity, empiricalPrior) {
// var listener = function(utterance,wonkinessPrior,speakerOptimality,cooperativity, empiricalWeight) {
                      Enumerate(function(){
                                var wonky = flip(wonkinessPrior)
                                // var wonkiness = uniformDraw([0.01,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.99])
                                // var prior = binomialMarbles(empiricalWeight - ((empiricalWeight-0.5)*wonky))
                                // var prior = binomialMarbles(empiricalWeight - ((empiricalWeight-0.5)*wonkiness*wonkyScale))
                                // var wonky = flip(wonkiness)
                                var prior = wonky ? 
                                // binomialMarbles(0.5) :
                                  [1,1,1,1,1,
                                  1,1,1,1,1,
                                  1,1,1,1,1,
                                  1]:
                                    empiricalPrior
                                var world = discrete(prior)
                                // var cooperative = flip(cooperativity)
                                // var S = (utterance=='mu') ? fillerSpeaker(world, prior) : speaker(world, prior, cooperativity)

                                // "null" utterance is equivalent to a completely uncooperative speaker
                                var S = (utterance=='mu') ? 0 : speaker(world, prior)
                                // console.log(wonky+ "..." + world +"..." + S.score([],utterance))

                                var scr = (utterance!='mu')  ? 
                                              speakerOptimality*S.score([],utterance) : 
                                              0
                                // console.log(scr)
                                factor(scr)
                                var queryStatement = {"world":world,
                                                      "wonky":wonky}
                                return queryStatement
//                                return map(function(s){return [s,Math.exp(S.score([],s))]},S.support())
//                                return sample(S)
                                })
                    }


var makeUrOwnBackoffListener = function(utterance,wonkinessPrior,speakerOptimality, primaryWeight, backoffWeight, accomodation, preprocessedPrior) {
// var listener = function(utterance,wonkinessPrior,speakerOptimality,cooperativity, empiricalWeight) {
                      Enumerate(function(){
                                var wonky = flip(wonkinessPrior)
                                // var wonkiness = uniformDraw([0.01,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.99])
                                // var prior = binomialMarbles(empiricalWeight - ((empiricalWeight-0.5)*wonky))
                                // var prior = binomialMarbles(empiricalWeight - ((empiricalWeight-0.5)*wonkiness*wonkyScale))
                                // var wonky = flip(wonkiness)
                                var prior =  wonky ? 
                                    binomialMarbles(backoffWeight) :
                                    binomialMarbles(primaryWeight)
                                  // [1,1,1,1,1,
                                  // 1,1,1,1,1,
                                  // 1,1,1,1,1,
                                  // 1]:
                                  //   empiricalPrior
                                var world = discrete(prior)
                                // var cooperative = flip(cooperativity)
                                // var S = (utterance=='mu') ? fillerSpeaker(world, prior) : speaker(world, prior, cooperativity)

                                // "null" utterance is equivalent to a completely uncooperative speaker
                                var priorOpts = {wonkinessPrior: wonkinessPrior,
                                                  primaryWeight: primaryWeight,
                                                  backoffWeight: backoffWeight
                                                }
                                var S = (utterance=='mu') ? 0 : speaker(world, prior, accomodation, priorOpts)

                                // return [wonky, world, Math.exp(S.score([], utterance))]
                                // console.log(wonky+ "..." + world +"..." + S.score([],utterance))

                                var scr = (utterance!='mu')  ? 
                                              speakerOptimality*S.score([],utterance) : 
                                              0
                                // console.log(scr)
                                factor(scr)
                                var queryStatement = {"world":world,
                                                      "wonky":wonky}
                                return queryStatement["world"]



//                                return map(function(s){return [s,Math.exp(S.score([],s))]},S.support())
//                                return sample(S)
                                })
                    }


// makeUrOwnBackoffListener("Some", 0.5, 2, 0.9, 0.3, 1)
// speaker(15, binomialMarbles(0.3), 0, {
//   wonkinessPrior:0.5,
//   primaryWeight: 0.9,
//   backoffWeight: 0.3
// })
// console.log("wRSA = " + expectation(makeUrOwnBackoffListener("Some", 0.5, 2, 0.9, 0.3, 1)))
// console.log("rRSA = " + expectation(makeUrOwnBackoffListener("Some", 0.5, 2, 0.9, 0.3, 0, null)))
makeUrOwnBackoffListener("Some", 0.5, 2, 0.99, 0.3, 0, null)
// console.log("rRSA = " + expectation(makeUrOwnBackoffListener("Some", 0.5, 2, 0.9, 0.3, 1, doubleBinomialMarbles(0.3,0.9,0.5))))

// console.log(expectation(literalListener("Some", binomialMarbles(0.3), 0, {
//   wonkinessPrior:0.5,
//   primaryWeight: 0.9,
//   backoffWeight: 0.3
// })))

// expectation(listener("Some",0.3, 3, 1, 0.999))
// speaker(5, binomialMarbles(0.5), 0.99)
// var results = listener("None", 0.4, 4, 0.99, binomialMarbles(0.9))

// console.log(expectation(results))

// console.log(binomialMarbles(0.99))

// results

// var normalize = function(dist){
//   return map(function(x){return x/sum(dist)}, dist)
// }

// var erp = listener("Some", 0, 3, 1, 0.5)
// expectation(erp)

// var empirical =  [.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,10] 
// var empirical_normalized = normalize(empirical)

// var backoff = [1,1,1,1,1,
//                                   1,1,1,1,1,
//                                   1,1,1,1,1,
//                                   1]

// var backoff_normalized = normalize(backoff)
// console.log( binomialMarbles(0.3))
// listener("Some", 0, 1, binomialMarbles(0.3))
// empirical_normalized


                                      // wonkyutils.fillArray(1,16) :
                                      // empiricalPriors[item]
                                      // [ 0.8,
                                      //     0.1,
                                      //     0.1013102,
                                      //     0.0160822,
                                      //     0.0076818,
                                      //     0.0359784,
                                      //     0.0054297,
                                      //     0.0008195,
                                      //     0.0001238,
                                      //     0.0000188,
                                      //     0.0000029,
                                      //     5e-7,
                                      //     2e-7,
                                      //     1e-7,
                                      //     1e-7,
                                      //     1e-7 ]
                                    // [.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,10]