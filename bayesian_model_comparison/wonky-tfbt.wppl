// webppl wonky-tfbt.wppl --require-js ./wonkyutils 

// helper functions

var shape_alpha = function(gamma,delta){return gamma * delta}
var shape_beta = function(gamma,delta){return (1-gamma) * delta}

var transpose = function(lst){
  return _.zip.apply(_, lst)
}

var discreteModelPredSliderVal = function(gamma, delta) {
  var discretizeBeta = function(gamma, delta){
    var bins = [0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1]
    var shape_alpha = gamma * delta
    var shape_beta = (1-gamma) * delta
    var betaPDF = function(x){
      return Math.pow(x,shape_alpha-1)*
          Math.pow((1-x),shape_beta-1)
    }
    return map(betaPDF, bins)
  }
  var quintileProbs = discretizeBeta(gamma,delta)
  var sliderVal = bins[discrete(quintileProbs)]
  return sliderVal
}


var modelScore = function(modelERP, data){
    return sum(
      map(
        function(d){return modelERP.score([],d)},
      data)
      )
  }


var numObjs = 15

var worldPrior = function() {
  var marbles = randomInteger(numObjs+1) //15 marbles... 0-15 can sink
  return marbles
}

var utterancePrior = function() {
  var utterances = ["some",
                    "all",
                    "none"]
  return uniformDraw(utterances)
}

var meaning = function(utt,world) {
  return utt=="some"? world>0 :
  utt=="all"? world==numObjs :
  utt=="none"? world==0 :
  true
}

var literalListener = cache(function(utterance, prior) {
                            Enumerate(function(){
                                      var world = discrete(prior)
                                      var m = meaning(utterance, world)
                                      factor(m?0:-Infinity)
                                      return world
                                      })
                            })

var speaker = cache(function(world, prior) {
                    Enumerate(function(){
                              var utterance = utterancePrior()
                              var L = literalListener(utterance, prior)
                              factor(L.score([],world))
                              return utterance
                              })
                    })

var listener = cache(function(utterance,wonkinessPrior,speakerOptimality,item) {
                      Enumerate(function(){
                                var wonky = flip(wonkinessPrior)
                                var prior = wonky ? 
                                      wonkyutils.fillArray(1,16) :
                                    [.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,1,5]
                                    //empiricalPriors[item]
                                var world = discrete(prior)
                                var S = speaker(world, prior)
                                factor(speakerOptimality*S.score([],utterance))
                                var queryStatement = {"world":world,
                                                      "wonky":wonky}
                                return queryStatement
                                })
                    })


var getMarginal = function(myERP, measure){
  Enumerate(function(){
    var x = sample(myERP)
    return x[measure]
  })

var linkingFunction = function(marginalERP, measure, linkingBetaConcentration){

    var posteriorProb = measure == "comprehensionAllProb" ? 
                                    Math.exp(marginalERP.score([], 15)):
                                    Math.exp(marginalERP.score([], true))

    // var queryStatement = sample(betaERP, [shape_alpha(posteriorProb, delta),
    //                                        shape_beta(posteriorProb, delta)])
    var queryStatement = discreteModelPredSliderVal(posteriorProb,delta)

    return queryStatement

}

var dataAnalysis = function(){

  // Priors
  // var speakerOptimality = sample(uniformERP, [0,10])
  var speakerOptimality = 0.1+(randomInteger(20)/4)
  // var wonkinessPriorPrior = sample(uniformERP, [0,10])
  var wonkinessPriorPrior = 0.01+(randomInteger(10)/10)
  var wonkySoftmax = randomInteger(10)
  // var linkingBetaConcentration = sample(uniformERP,[0,10])
  var linkingBetaConcentration = (randomInteger(10)+1)/3

  var posteriorPredictive = 
    map(function(item){

      return map(function(utterance){

        var predictionERP = listener(utterance, wonkinessPrior, speakerOptimality,item,measure)

        return map(function(measure){

          var dataPoints = dataObject[measure][item][utterance]
          var marginalERP = getMarginal(predictionERP, measure)

          // if comprehension task "give a number", use the marginal posterior directly
          // otherwise, need to connect to the slider value somehow
          // here, we assume the slider value is the mean of a beta (possibly discretized, for implementation)
          // and there is some concentration (delta) variable; this is a mere nuisance, data-analysis parameter
          var linkedERP = measure == "comprehensionNumber" ?
                            marginalERP :
                            linkingFunction(marginalERP, measure, linkingBetaConcentration)

          return modelScore(linkedERP, dataObject[measure][item][utterance])
          
          // factor(modelScore(linkedERP, dataObject[measure][item][utterance]))
          // return [measure, item, utterance, 
          //           Math.exp(predictionERP.score([], 15))]

          }, ["comprehensionNumber","comprehensionAllProb","wonkiness"])

        }, ["some","all","none"])

      }, listOf90Items)
}

